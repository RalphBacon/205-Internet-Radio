// All of the ILI9341 TFT Touch Screen routines are included here
#include "Arduino.h"
#include "main.h"

// Bitmap display helper (Bodmer's)
#include "bitmapHelper.h"

// autogenerated build number (see https://gitlab.com/pvojnisek/buildnumber-for-platformio/tree/master)
#include <version.h>

// IMPORTANT: you MUST run the touch calibration sketch to store the values
// for future runs of the sketch (ie run once, in the orientation you expect
// to use the screen)

// Generic button width & height
#define BUTTON_W 30
#define BUTTON_H 26

// Station change icon/button position (titlebar)
#define STATION_CHANGE_X 278
#define STATION_CHANGE_Y 11

// Bulb button / icon
#define BULB_BUTTON_X 105
#define BULB_BUTTON_Y 205
#define BULB_ICON_X 89
#define BULB_ICON_Y 190

// Plus button
#define PLUS_BUTTON_X 128
#define PLUS_BUTTON_Y 193

// Minus button NEXT_BUTTON_X + 130, NEXT_BUTTON_Y + 3
#define MINUS_BUTTON_X 169
#define MINUS_BUTTON_Y 193

// Mute button / icon
#define MUTE_BUTTON_X 204
#define MUTE_BUTTON_Y 190
#define MUTE_ICON_X 206
#define MUTE_ICON_Y BULB_ICON_Y

// Buffer label
#define BUFFER_X 250
#define BUFFER_Y 190

// There are 10 bytes (5 integers @ 2 bytes each) for TFT calibration
#define totCalibrationBytes 10

// Visual indicator type
enum percentageLineType
{
	VOLUME,
	BRIGHTNESS,
	CLEAR
};

//TFT_eSPI_Button muteBtn, brightBtn, dimBtn;
TFT_eSPI_Button spkrBtn, plusBtn, minusBtn, stnChangeBtn, bulbBtn, dummyPlusBtn, dummyMinusBtn;

// Display routines (hardware/protocol dependent)
void initDisplay()
{
	// NOTE: LITTLEFS must have been mounted prior to calling this helper

	// check if calibration file exists and size is correct
	if (LITTLEFS.exists("/TouchCalData1.txt"))
	{
		File f = LITTLEFS.open("/TouchCalData1.txt", "r");
		if (f)
		{
			// Buffer (integer 2 bytes * 5) to hold calibration data
			uint16_t calData[5];

			// On calibration, 14 bytes were written. TODO: why?
			//if (f.readBytes((char *)calData, 14) == 14)
			if (f.readBytes((char *)calData, totCalibrationBytes) == totCalibrationBytes)
				tft.setTouch(calData);

			log_v("TFT Calibration data:");
			for (auto cnt = 0; cnt < totCalibrationBytes; cnt++)
			{
				log_v("%04X, ", calData[cnt]);
			}

			f.close();
			log_i("Touch Calibration completed");
		}
	}
	else
	{
		log_e("NO TOUCH CALIBRATION FILE FOUND");
		displayTrackArtist("NO TOUCH CALIBRATION FILE FOUND");
	}

	// TODO: Change "text" buttons to jpg images with "invisible" buttons (eg black on black) to get the
	// functionality of a button but a better visual experience

	// Change station button (transparent, behind a bmp)
	stnChangeBtn.initButtonUL(
		&tft, STATION_CHANGE_X, STATION_CHANGE_Y, BUTTON_W, BUTTON_H, TFT_RED, TFT_RED, TFT_TRANSPARENT, (char *)" ", 1);

	// Allow screen brightness, black, bitmap painted over it
	bulbBtn.initButton(
		&tft, BULB_BUTTON_X, BULB_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_BLACK, TFT_BLACK, TFT_BLACK, (char *)"?", 1);

	// Brighten the screen or increase the volume
	plusBtn.initButtonUL(
		&tft, PLUS_BUTTON_X, PLUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_YELLOW, TFT_BLUE, TFT_WHITE, (char *)"+", 1);

	// Dim the screen or reduce the volume
	minusBtn.initButtonUL(
		&tft, MINUS_BUTTON_X, MINUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_YELLOW, TFT_MAROON, TFT_WHITE, (char *)"-", 1);

	// Black icon, no text, bitmap painted over it
	spkrBtn.initButtonUL(
		&tft, MUTE_BUTTON_X, MUTE_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_BLACK, TFT_BLACK, TFT_BLACK, (char *)"", 1);

	// Dummy plus and minus buttons that do NOTHING (placeholders)
	dummyPlusBtn.initButtonUL(
		&tft, PLUS_BUTTON_X, PLUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_ORANGE, TFT_DARKGREY, TFT_LIGHTGREY, (char *)"+", 1);

	dummyMinusBtn.initButtonUL(
		&tft, MINUS_BUTTON_X, MINUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_ORANGE, TFT_DARKGREY, TFT_LIGHTGREY, (char *)"-", 1);

	// Run once
	setupDisplayModule(true);
}

// Put the TFT specific code here to prepare your screen, called again on return to HOME screen
void setupDisplayModule(bool initialiseHardWare)
{
	// Initialise
	if (initialiseHardWare)
	{
		tft.init();
	}

	// Rotation as required, the touch calibration MUST match this
	// 0 & 2 Portrait. 1 & 3 landscape
	tft.setRotation(1);

	// Write title of app on screen, using font 2 (x, y, font #)
	tft.fillScreen(TFT_BLACK);

	// Border + fill
	tft.fillRect(1, 1, 318, 43, TFT_RED);
	tft.drawRect(0, 0, 320, 45, TFT_YELLOW);

	// Application Title
	tft.setFreeFont(&FreeSansBold12pt7b);
	tft.setTextSize(1);
	tft.setCursor(26, 30);

	// Set text colour and background
	tft.setTextColor(TFT_YELLOW, TFT_RED);
	tft.println("- ESP32 WEB RADIO -");

	// Version number (set in platformio.ini)
	tft.setTextFont(2);
	tft.setCursor(200, 2);
	tft.setRotation(0);
	tft.print(VERSION_SHORT);
	tft.setRotation(1);

	// My details
	tft.setTextFont(2);
	tft.setTextColor(TFT_SKYBLUE, TFT_BLACK);
	tft.setCursor(5, tft.height() - 20);
	tft.println("Ralph S Bacon - https://youtube.com/ralphbacon");

	/* 
		Draw button(s)
	*/

	// In title bar the transmitter icon
	drawStnChangeButton();
	drawStnChangeBitmap();

	// Screen brightness control
	drawBulbButton();
	drawBulbBitmap();

	// The + and - buttons to control screen brightness and volume
	//drawBrightButton(false);
	//drawDimButton(false);
	drawPlusButton(false);
	drawMinusButton(false);

	// Volume control (and mute)
	spkrStatus = BTN_ACTIVE;
	drawSpkrButton(false);
	drawSpkrBitmap();

	// Simple percentage indication of active button (volume or brightness)
	// Don't draw this during initial setp
	if (!initialiseHardWare)
	{
		drawPercentageLine(VOLUME);
	}

	// Signal (buffer) updated frequently
	drawBufferLevel(circBuffer.available());

	// All done
	log_i("TFT Initialised");
	return;
}

// Draw the volume or brightness visual indicator
void drawPercentageLine(int lineType)
{
#define volLineX 127
#define volLineY 181
#define volWidthMax 108

#define dimLineX 90
#define dimLineY 181
#define dimWidthMax 108

	switch (lineType)
	{
	case VOLUME:
	{

		// Calculate line length according to current volume setting
		// Ensure volume is minimum of 50 (inaudible)
		uint8_t currVol = max((int)player.getVolume(), 50);

		// value, in_min, in_max, out_min, out_max
		uint8_t volWidth = map(currVol, 50, 100, 5, volWidthMax);
		log_v("Volume %d, volume line length %d", currVol, volWidth);

		// Top line + clearing remainder
		tft.drawFastHLine(volLineX, volLineY, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY, volWidthMax - volWidth, TFT_YELLOW);

		// Middle line
		tft.drawFastHLine(volLineX, volLineY + 1, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY + 1, volWidthMax - volWidth, TFT_YELLOW);

		// Bottom line (repeat of first line)
		tft.drawFastHLine(volLineX, volLineY + 2, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY + 2, volWidthMax - volWidth, TFT_YELLOW);
		break;
	}

	case BRIGHTNESS:
	{
		// Brightness goes from 20 to 255
		uint8_t dimWidth = map(prevTFTBright, 20, 255, 0, dimWidthMax);
		log_v("Brightness %d, bright line length %d", prevTFTBright, dimWidth);

		// Top line + clearing remainder
		tft.drawFastHLine(dimLineX, dimLineY, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY, dimWidthMax - dimWidth, TFT_YELLOW);

		// Middle line
		tft.drawFastHLine(dimLineX, dimLineY + 1, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY + 1, dimWidthMax - dimWidth, TFT_YELLOW);

		// Bottom line (repeat of first line)
		tft.drawFastHLine(dimLineX, dimLineY + 2, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY + 2, dimWidthMax - dimWidth, TFT_YELLOW);
		break;
	}

	case CLEAR:
		log_v("Percentage line cleared from %d to %d", dimLineX, volLineX - dimLineX + volWidthMax);
		tft.fillRect(dimLineX, dimLineY, volLineX - dimLineX + volWidthMax, 3, TFT_BLACK);
		break;

	default:
	{
		log_d("Invalid Percentage Line Type %d", lineType);
		break;
	}
	}
}

// Some track titles are ALL IN UPPER CASE, so ugly, so let's convert them
// Stackoverflow: https://stackoverflow.com/a/64128715
std::string toTitle(std::string s, const std::locale &loc)
{
	// Is the current character a word delimiter (a space)?
	bool last = true;

	// Process each character in the supplied string
	for (char &c : s)
	{
		// If the previous character was a word delimiter (space)
		// then upper case current word start, else make lower case
		c = last ? std::toupper(c, loc) : std::tolower(c, loc);

		// Is this character a space?
		last = std::isspace(c, loc);
	}
	return s;
}

// Draw proof-of-concept station change button TODO: expose coordinates
void drawStnChangeButton()
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	stnChangeBtn.setLabelDatum(0, 2);
	stnChangeBtn.drawButton();
}

// Place the "change station" button in the title bar to save space
void drawStnChangeBitmap(bool pressed)
{
	drawBmp(pressed ? "/tuneSmallPressed.bmp" : "/tuneSmall.bmp", STATION_CHANGE_X, STATION_CHANGE_Y);
}

// Mute button uses object
void drawSpkrButton(bool invert)
{
	//tft.setFreeFont(&FreeSansBold9pt7b);
	//tft.setTextSize(1);
	spkrBtn.drawButton(invert);
}

void drawSpkrBitmap()
{
	if (spkrStatus == BTN_ACTIVE)
	{
		if (isMutedState)
		{
			drawBmp("/SpkrIconActiveMuted.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
		else
		{
			drawBmp("/SpkrIconActive.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
	}
	else
	{
		if (isMutedState)
		{
			drawBmp("/SpkrIconInactiveMuted.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
		else
		{
			drawBmp("/SpkrIconInactive.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
	}
}

void drawPlusButton(bool invert)
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	plusBtn.drawButton(invert);
}

void drawMinusButton(bool invert)
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	minusBtn.drawButton(invert);
}

// Screen brightness control
void drawBulbButton()
{
	bulbBtn.drawButton();
}

void drawBulbBitmap(bool active)
{
	drawBmp(active ? "/BulbIconActive.bmp" : "/BulbIconOff.bmp", BULB_ICON_X, BULB_ICON_Y);
}

// Draw percentage of buffering (eg 10000 buffer that uses 8000 bytes = 80%)
void drawBufferLevel(size_t bufferLevel, bool override)
{
	static unsigned long prevMillis = millis();
	static int prevBufferPerCent = 0;

	// Only do this infrequently and if the buffer % changes
	if (millis() - prevMillis > 500 || override)
	{
		// Capture current values for next time
		prevMillis = millis();

		// Calculate the percentage (ESP32 has FP processor so shoud be efficient)
		float bufLevel = (float)bufferLevel;
		float arraySize = (float)(CIRCULARBUFFERSIZE);
		int bufferPerCent = (bufLevel / arraySize) * 100.0;

		// Only update the screen on real change (avoids flicker & saves time)
		if (bufferPerCent != prevBufferPerCent || override)
		{
			// Track the buffer percentage
			prevBufferPerCent = bufferPerCent;

			// Print at specific rectangular place
			// TODO: These should not be magic numbers
			uint16_t bgColour, fgColour;
			switch (bufferPerCent)
			{
			case 0 ... 30:
				bgColour = TFT_RED;
				fgColour = TFT_WHITE;
				break;

			case 31 ... 74:
				bgColour = TFT_ORANGE;
				fgColour = TFT_BLACK;
				break;

			case 75 ... 100:
				bgColour = TFT_DARKGREEN;
				fgColour = TFT_WHITE;
				break;

			default:
				bgColour = TFT_WHITE;
				fgColour = TFT_BLACK;
			};

			tft.fillRoundRect(BUFFER_X, BUFFER_Y, 60, 30, 5, bgColour);
			tft.drawRoundRect(BUFFER_X, BUFFER_Y, 60, 30, 5, TFT_RED);
			tft.setTextColor(fgColour, bgColour);
			tft.setFreeFont(&FreeSans9pt7b);
			tft.setTextSize(1);
			tft.setCursor(BUFFER_X + 11, BUFFER_Y + 20);
			tft.printf("%d%%\n", bufferPerCent);
		}
	}
}

// On screen Station Change button (called from main.cpp when TFT touch detected)
// Note that the button is invisible and what you see is a bitmap.
bool getStnChangeButtonPress()
{
	uint16_t t_x = 0, t_y = 0;
	boolean pressed = tft.getTouch(&t_x, &t_y, 50);
	if (pressed && stnChangeBtn.contains(t_x, t_y))
	{
		//log_v("Stn Change: x=%d, y=%d\n", t_x, t_y);
		log_d("Station change button pressed");
		drawStnChangeBitmap(true);

		// While the button is pressed (screen is touched) wait
		while (!digitalRead(tftTouchedPin))
			;
		{
			// give up remainder of this 1mS time slice
			taskYIELD();
		}

		log_d("Station change button released");
		return true;
	}

	return false;
}

// Increase brightness
void getPlusButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently or buffer will stop
	if (millis() - prevMillis > 150)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y);

		// Check if any key coordinate boxes contain the touch coordinates
		// and highlight the buttons appropriately
		if (pressed && plusBtn.contains(t_x, t_y))
		{
			plusBtn.press(true);
		}
		else
		{
			plusBtn.press(false);
		}

		if (plusBtn.justPressed())
		{
			drawPlusButton(true);

			// SCREEN BRIGHTNESS
			if (bulbStatus == BTN_ACTIVE)
			{
				log_v("Brighter!");

				if (prevTFTBright <= 235)
				{
					prevTFTBright += 20;
					ledcWrite(0, prevTFTBright);

					// Update visual indicator
					drawPercentageLine(BRIGHTNESS);

					//Store brightness level in EEPROM
					preferences.putUInt("Bright", prevTFTBright);
				}
			}

			// MUSIC VOLUME
			if (spkrStatus == BTN_ACTIVE)
			{
				log_v("Louder!");
				uint8_t playerVolume = player.getVolume();
				if (playerVolume < 100)
				{
					// Prevent going above 100
					//player.setVolume(min((int)playerVolume + 1, 100));
					userVolume++;
					targetVolume = userVolume;

					// Update visual indicator
					drawPercentageLine(VOLUME);

					//Store volume level in EEPROM
					preferences.putUInt("Volume", userVolume);
				}
			}
		}
		else if (plusBtn.justReleased())
		{
			drawPlusButton(false);
		}
	}
}

// Decrease brightness
void getMinusButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently or buffer will stop
	if (millis() - prevMillis > 150)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y);

		// Check if any key coordinate boxes contain the touch coordinates
		if (pressed && minusBtn.contains(t_x, t_y))
		{
			minusBtn.press(true);
		}
		else
		{
			minusBtn.press(false);
		}

		if (minusBtn.justPressed())
		{
			drawMinusButton(true);

			// SCREEN BRIGHTNESS
			if (bulbStatus == BTN_ACTIVE)
			{
				log_v("Dimmer!");

				if (prevTFTBright >= 20)
				{
					prevTFTBright -= 20;
					ledcWrite(0, prevTFTBright);

					// Update visual indicator
					drawPercentageLine(BRIGHTNESS);

					//Store brightness level in EEPROM
					preferences.putUInt("Bright", prevTFTBright);
				}
			}

			// SPEAKER VOLUME
			if (spkrStatus == BTN_ACTIVE)
			{
				log_v("Quieter!");
				uint8_t playerVolume = player.getVolume();

				// Only allow reduction to +50 (very, very quiet)
				if (playerVolume >= 50)
				{
					//player.setVolume(playerVolume - 1);
					userVolume = playerVolume - 1;
					targetVolume = userVolume;

					// Update visual indicator
					drawPercentageLine(VOLUME);

					//Store volume level in EEPROM
					preferences.putUInt("Volume", userVolume);
				}
			}
		}
		else if (minusBtn.justReleased())
		{
			drawMinusButton(false);
		}
	}
}

// Speaker button to control volume and muting (stays active until bulb button pressed)
void getSpkrButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently
	if (millis() - prevMillis > 250)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Did we press the spearker button icon/button
		boolean pressed = tft.getTouch(&t_x, &t_y, 20);
		if (pressed && spkrBtn.contains(t_x, t_y))
		{
			log_d("Speaker button pressed");

			// Deactivate the bulb button if required
			if (bulbStatus == BTN_ACTIVE)
			{
				// Clear percentage line (from brightness)
				drawPercentageLine(CLEAR);

				// Disable bulb icon
				bulbStatus = BTN_INACTIVE;
				drawBulbBitmap(bulbStatus);

				// Enable speaker icon
				spkrStatus = BTN_ACTIVE;
				drawSpkrBitmap();

				// In/activate the plus/minus buttons depending on mute state
				// No change in volume level required here, continue with old value
				if (isMutedState)
				{
					drawDummyPlusMinusButtons();
				}
				else
				{
					drawPlusButton(false);
					drawMinusButton(false);
				}

				// Show current volume
				drawPercentageLine(VOLUME);

				// While the button is pressed (screen is touched) wait, to stop
				// the mute/unmute state switching many times whilst being pressed
				while (!digitalRead(tftTouchedPin))
				{
					// give up remainder of this 1mS time slice
					taskYIELD();
				}
			}
			else
			{
				// The speaker button is already ACTIVE we can toggle the mute sound
				isMutedState = !isMutedState;
				log_d("Mute: %s", isMutedState ? "Muted" : "UNmuted");

				// If we have unmuted the sound turn it up and vice versa
				// Volume will be adjusted in main loop(). NB Min volume = 1 to stop clicks
				targetVolume = isMutedState ? 1 : userVolume;
				drawSpkrBitmap();

				// In/activate the plus/minus buttons depending on mute state
				if (isMutedState)
				{
					drawDummyPlusMinusButtons();
				}
				else
				{
					drawPlusButton(false);
					drawMinusButton(false);
				}

				// While the button is pressed (screen is touched) wait to stop
				// the mute/unmute state switching many times
				while (!digitalRead(tftTouchedPin))
				{
					// give up remainder of this 1mS time slice
					taskYIELD();
				}
			}
		}
	}
}

// Brightness BULB icon
void getBulbButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently and only if mute button not active
	if (millis() - prevMillis > 500)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y, 50);

		// Check if any key coordinate boxes contain the touch coordinates
		if (pressed && bulbBtn.contains(t_x, t_y))
		{
			log_d("Bulb button pressed");

			// Clear percentage line (from volume)
			drawPercentageLine(CLEAR);

			// Draw activated bulb button
			bulbStatus = BTN_ACTIVE;
			drawBulbBitmap(bulbStatus);

			// Deactivate the speaker icon
			spkrStatus = BTN_INACTIVE;
			drawSpkrBitmap();

			// Paint the plus/minus buttons
			if (bulbStatus == BTN_ACTIVE)
			{
				drawMinusButton(false);
				drawPlusButton(false);
			}

			// Show the current brightness
			drawPercentageLine(BRIGHTNESS);
		}
	}
}

void displayStationName(std::string stationName)
{
	// Set text colour and background
	tft.setTextColor(TFT_YELLOW, TFT_BLACK);

	// Clear the remainder of the line from before (eg long title)
	tft.fillRect(0, 56, 320, 40, TFT_BLACK);

	// Write station name (as stored in the sketch)
	tft.setCursor(0, 85);
	tft.setFreeFont(&FreeSansOblique12pt7b);
	tft.setTextSize(1);
	tft.println(stationName.c_str());
}

// Incoming string will normally be in the format Artist - Title
// But some stations do it the other way around. No standards here.
void displayTrackArtist(std::string trackArtistIn)
{
	// Placeholder strings for final output
	std::string justArtist;
	std::string justTitle;

	// Convert string to character array (because that's how I originally wrote this)
	char *trackArtist = (char *)trackArtistIn.c_str();

	// Did we split this string successfully?
	bool splitSuccessful = false;

	// Find where the artist & track are split (if they are)
	char *pointerToDelimiter;
	pointerToDelimiter = strstr(trackArtist, " - ");
	int startCnt = (int)(pointerToDelimiter - trackArtist);

	// If a delimiter was found
	if (pointerToDelimiter != NULL)
	{
		log_v("Found delimiter at position %d", startCnt);

		// Make a new (sub) string of the first part (not including the delimiter)
		std::string justArtistTemp(&trackArtist[0], &trackArtist[startCnt]);
		justArtist = justArtistTemp;
		log_d("Artist: '%s'", justArtist.c_str());

		// Make a new (sub) string of the last part (skipping over the delimiter)
		std::string justTitleTemp(&trackArtist[startCnt + 3], trackArtistIn.size());
		justTitle = justTitleTemp;
		log_d("Title: '%s'", justTitle.c_str());

		// Success
		splitSuccessful = true;
	}
	else
	{
		// Couldn't find a delimiter
		log_v("No delimiter found - using default value");
	}

	// Set default text colour and background
	tft.setTextColor(TFT_GREEN, TFT_BLACK);

	// Clear the remainder of the line from before (eg long title)
	tft.fillRect(0, 100, 320, 80, TFT_BLACK);

	// Write artist / track info
	tft.setFreeFont(&FreeSans9pt7b);
	tft.setTextSize(1);
	tft.setCursor(0, 120);

	// Change colours if we split the string successfully
	if (splitSuccessful)
	{
		// Default colour
		tft.println(justArtist.c_str());

		// Larger font, differentiating colour
		tft.setFreeFont(&FreeSans12pt7b);
		tft.setTextColor(TFT_ORANGE, TFT_BLACK);
		tft.print(justTitle.c_str());
	}
	else
	{
		// Default colour
		tft.print(trackArtistIn.c_str());
	}
}

// Inactive plus/minus buttons, only shown when sound is muted
void drawDummyPlusMinusButtons()
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	dummyPlusBtn.drawButton();
	dummyMinusBtn.drawButton();
}