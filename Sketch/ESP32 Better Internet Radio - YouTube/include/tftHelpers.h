// All of the ILI9341 TFT Touch Screen routines are included here
#include "Arduino.h"
#include "main.h"

// Bitmap display helper (Bodmer's)
#include "bitmapHelper.h"

// autogenerated build number (see https://gitlab.com/pvojnisek/buildnumber-for-platformio/tree/master)
#include "version.h"

// IMPORTANT: you MUST run the touch calibration sketch to store the values
// for future runs of the sketch (ie run once, in the orientation you expect
// to use the screen)

// Generic button width & height
#define BUTTON_W 30
#define BUTTON_H 26

// Station change icon/button position (titlebar)
#define STATION_CHANGE_X 278
#define STATION_CHANGE_Y 11

// Bulb button / icon
#define BULB_BUTTON_X 105
#define BULB_BUTTON_Y 205
#define BULB_ICON_X 89
#define BULB_ICON_Y 190

// Plus button
#define PLUS_BUTTON_X 128
#define PLUS_BUTTON_Y 193

// Minus button NEXT_BUTTON_X + 130, NEXT_BUTTON_Y + 3
#define MINUS_BUTTON_X 169
#define MINUS_BUTTON_Y 193

// Mute button / icon
#define MUTE_BUTTON_X 204
#define MUTE_BUTTON_Y 190
#define MUTE_ICON_X 206
#define MUTE_ICON_Y BULB_ICON_Y

// Buffer label
#define BUFFER_X 250
#define BUFFER_Y 190
#define BUFFER_W 60
#define BUFFER_H 30

// Settings button (switches to settings screen)
#define SET_X 10
#define SET_Y 190

// There are 10 bytes (5 integers @ 2 bytes each) for TFT calibration
#define totCalibrationBytes 10

// Visual indicator type
enum percentageLineType
{
	VOLUME,
	BRIGHTNESS,
	CLEAR
};

//TFT_eSPI_Button muteBtn, brightBtn, dimBtn;
TFT_eSPI_Button spkrBtn, plusBtn, minusBtn, stnChangeBtn, bulbBtn, dummyPlusBtn, dummyMinusBtn, settingsBtn;

// Display routines (hardware/protocol dependent)
void initDisplay()
{
	// NOTE: LITTLEFS must have been mounted prior to calling this helper

	// check if calibration file exists and size is correct
	if (LITTLEFS.exists("/TouchCalData1.txt"))
	{
		File f = LITTLEFS.open("/TouchCalData1.txt", "r");
		if (f)
		{
			// Buffer (integer 2 bytes * 5) to hold calibration data
			uint16_t calData[5];

			// Refer to the example file Touch_calibrate.ino (in Generic) for the format
			if (f.readBytes((char *)calData, totCalibrationBytes) == totCalibrationBytes)
			{
				tft.setTouch(calData);
			}

			log_v("TFT Calibration data:");
			for (auto cnt = 0; cnt < totCalibrationBytes / sizeof(uint16_t); cnt++)
			{
				log_d("%04X, ", calData[cnt]);
			}

			f.close();
			log_i("Touch Calibration completed");
		}
	}
	else
	{
		log_e("NO TOUCH CALIBRATION FILE FOUND");
		displayTrackArtist("NO TOUCH CALIBRATION FILE FOUND");
	}

	// TODO: Change "text" buttons to jpg images with "invisible" buttons (eg black on black) to get the
	// functionality of a button but a better visual experience

	// Change station button (transparent, behind a bmp)
	stnChangeBtn.initButtonUL(
		&tft, STATION_CHANGE_X, STATION_CHANGE_Y, BUTTON_W, BUTTON_H, TFT_RED, TFT_RED, TFT_TRANSPARENT, (char *)" ", 1);

	// Allow screen brightness, black, bitmap painted over it
	bulbBtn.initButton(
		&tft, BULB_BUTTON_X, BULB_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_BLACK, TFT_BLACK, TFT_BLACK, (char *)"?", 1);

	// Brighten the screen or increase the volume
	plusBtn.initButtonUL(
		&tft, PLUS_BUTTON_X, PLUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_YELLOW, TFT_BLUE, TFT_WHITE, (char *)"+", 1);

	// Dim the screen or reduce the volume
	minusBtn.initButtonUL(
		&tft, MINUS_BUTTON_X, MINUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_YELLOW, TFT_MAROON, TFT_WHITE, (char *)"-", 1);

	// Black icon, no text, bitmap painted over it
	spkrBtn.initButtonUL(
		&tft, MUTE_BUTTON_X, MUTE_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_BLACK, TFT_BLACK, TFT_BLACK, (char *)"", 1);

	// Dummy plus and minus buttons that do NOTHING (placeholders)
	dummyPlusBtn.initButtonUL(
		&tft, PLUS_BUTTON_X, PLUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_ORANGE, TFT_DARKGREY, TFT_LIGHTGREY, (char *)"+", 1);

	dummyMinusBtn.initButtonUL(
		&tft, MINUS_BUTTON_X, MINUS_BUTTON_Y, BUTTON_W, BUTTON_H, TFT_ORANGE, TFT_DARKGREY, TFT_LIGHTGREY, (char *)"-", 1);

	settingsBtn.initButtonUL(
		&tft, SET_X, SET_Y, BUTTON_W * 1.5, BUTTON_H, TFT_YELLOW, TFT_BLACK, TFT_RED, (char *)"SET", 1);

	// Run once
	setupDisplayModule(true);
}

// Put the TFT specific code here to prepare your screen, called again on return to HOME screen
void setupDisplayModule(bool initialiseHardWare)
{
	// Initialise
	if (initialiseHardWare)
	{
		tft.init();
	}

	// Rotation as required, the touch calibration MUST match this
	// 0 & 2 Portrait. 1 & 3 landscape
	tft.setRotation(1);

	// Write title of app on screen, using font 2 (x, y, font #)
	tft.fillScreen(TFT_BLACK);

	// Border + fill
	tft.fillRect(1, 1, 318, 43, TFT_RED);
	tft.drawRect(0, 0, 320, 45, TFT_YELLOW);

	// Application Title
	tft.setFreeFont(&FreeSansBold12pt7b);
	tft.setTextSize(1);
	tft.setCursor(41, 30);

	// Set text colour and background
	tft.setTextColor(TFT_YELLOW, TFT_RED);
	tft.println("ESP32 WEB RADIO");

	// Version number (set in platformio.ini)
	tft.setTextFont(2);
	tft.setCursor(200, 2);
	tft.setRotation(0);
	tft.print(VERSION_SHORT);
	tft.setRotation(1);

	// My details
	tft.setTextFont(2);
	tft.setTextColor(TFT_SKYBLUE, TFT_BLACK);
	tft.setCursor(5, tft.height() - 20);
	tft.println("Ralph S Bacon - https://youtube.com/ralphbacon");

	/* 
		Draw button(s)
	*/

	// In title bar the transmitter icon
	drawStnChangeButton();
	drawStnChangeBitmap();

	// Screen brightness control
	drawBulbButton();
	drawBulbBitmap();

	// The + and - buttons to control screen brightness and volume
	//drawBrightButton(false);
	//drawDimButton(false);
	drawPlusButton(false);
	drawMinusButton(false);

	// Volume control (and mute)
	spkrStatus = BTN_ACTIVE;
	drawSpkrButton(false);
	drawSpkrBitmap();

	// Settings
	drawSettingsBtn();

	// Simple percentage indication of active button (volume or brightness)
	// Don't draw this during initial setp
	if (!initialiseHardWare)
	{
		drawPercentageLine(VOLUME);
	}

	// Signal (buffer) updated frequently
	drawBufferLevel(circBuffer.available());

	// All done
	log_i("TFT Initialised");
	return;
}

// Draw the volume or brightness visual indicator
void drawPercentageLine(int lineType)
{
#define volLineX 127
#define volLineY 181
#define volWidthMax 108

#define dimLineX 90
#define dimLineY 181
#define dimWidthMax 108

	switch (lineType)
	{
	case VOLUME:
	{

		// Calculate line length according to current volume setting
		// Ensure volume is minimum of 50 (inaudible)
		uint8_t currVol = max((int)player.getVolume(), 50);

		// value, in_min, in_max, out_min, out_max
		uint8_t volWidth = map(currVol, 50, 100, 5, volWidthMax);
		//log_v("Volume %d, volume line length %d", currVol, volWidth);

		// Top line + clearing remainder
		tft.drawFastHLine(volLineX, volLineY, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY, volWidthMax - volWidth, TFT_YELLOW);

		// Middle line
		tft.drawFastHLine(volLineX, volLineY + 1, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY + 1, volWidthMax - volWidth, TFT_YELLOW);

		// Bottom line (repeat of first line)
		tft.drawFastHLine(volLineX, volLineY + 2, volWidth, TFT_RED);
		tft.drawFastHLine(volLineX + volWidth, volLineY + 2, volWidthMax - volWidth, TFT_YELLOW);
		break;
	}

	case BRIGHTNESS:
	{
		// Brightness goes from 20 to 255
		uint8_t dimWidth = map(prevTFTBright, 20, 255, 0, dimWidthMax);
		log_v("Brightness %d, bright line length %d", prevTFTBright, dimWidth);

		// Top line + clearing remainder
		tft.drawFastHLine(dimLineX, dimLineY, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY, dimWidthMax - dimWidth, TFT_YELLOW);

		// Middle line
		tft.drawFastHLine(dimLineX, dimLineY + 1, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY + 1, dimWidthMax - dimWidth, TFT_YELLOW);

		// Bottom line (repeat of first line)
		tft.drawFastHLine(dimLineX, dimLineY + 2, dimWidth, TFT_RED);
		tft.drawFastHLine(dimLineX + dimWidth, volLineY + 2, dimWidthMax - dimWidth, TFT_YELLOW);
		break;
	}

	case CLEAR:
		log_v("Percentage line cleared from %d to %d", dimLineX, volLineX - dimLineX + volWidthMax);
		tft.fillRect(dimLineX, dimLineY, volLineX - dimLineX + volWidthMax, 3, TFT_BLACK);
		break;

	default:
	{
		log_d("Invalid Percentage Line Type %d", lineType);
		break;
	}
	}
}

// Some track titles are ALL IN UPPER CASE, so ugly, so let's convert them
// Stackoverflow: https://stackoverflow.com/a/64128715
std::string toTitle(std::string s, const std::locale &loc)
{
	// Is the current character a word delimiter (a space)?
	bool last = true;

	// Process each character in the supplied string
	for (char &c : s)
	{
		// If the previous character was a word delimiter?
		// then upper case current word start, else make lower case
		c = last ? std::toupper(c, loc) : std::tolower(c, loc);

		// Is this character a space? Or brackets? Note that "ispunct" won't work here!
		// We have to cater for things like Forever(And ever) and A7S and R.E.M. just to name a few
		// TODO: Also, we have to deal with names like O'Connor.
		// TODO: Also, we must not lower case words like BBC
		std::string validPunctuation = "().-,`";
		last = std::isspace(c, loc) || std::isdigit(c, loc) || validPunctuation.find(c) != std::string::npos;
	}
	return s;
}

// Draw proof-of-concept station change button TODO: expose coordinates
void drawStnChangeButton()
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	stnChangeBtn.setLabelDatum(0, 2);
	stnChangeBtn.drawButton();
}

// Place the "change station" button in the title bar to save space
void drawStnChangeBitmap(bool pressed)
{
	drawBmp(pressed ? "/tuneSmallPressed.bmp" : "/tuneSmall.bmp", STATION_CHANGE_X, STATION_CHANGE_Y);
}

// Mute button uses object
void drawSpkrButton(bool invert)
{
	//tft.setFreeFont(&FreeSansBold9pt7b);
	//tft.setTextSize(1);
	spkrBtn.drawButton(invert);
}

void drawSpkrBitmap()
{
	if (spkrStatus == BTN_ACTIVE)
	{
		if (isMutedState)
		{
			drawBmp("/SpkrIconActiveMuted.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
		else
		{
			drawBmp("/SpkrIconActive.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
	}
	else
	{
		if (isMutedState)
		{
			drawBmp("/SpkrIconInactiveMuted.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
		else
		{
			drawBmp("/SpkrIconInactive.bmp", MUTE_ICON_X, MUTE_ICON_Y);
		}
	}
}

void drawPlusButton(bool invert)
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	plusBtn.drawButton(invert);
}

void drawMinusButton(bool invert)
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	minusBtn.drawButton(invert);
}

void drawSettingsBtn()
{
	tft.setFreeFont(&FreeSans9pt7b);
	settingsBtn.setLabelDatum(0, +2);
	settingsBtn.drawButton(false);
}

// Screen brightness control
void drawBulbButton()
{
	bulbBtn.drawButton();
}

void drawBulbBitmap(bool active)
{
	drawBmp(active ? "/BulbIconActive.bmp" : "/BulbIconOff.bmp", BULB_ICON_X, BULB_ICON_Y);
}

// Draw percentage of buffering (eg 10000 buffer that uses 8000 bytes = 80%)
void drawBufferLevel(size_t bufferLevel, bool override)
{
	if (currDisplayScreen != HOME)
		return;

	static unsigned long prevMillis = millis();
	static int prevBufferPerCent = 0;

	// Only do this infrequently and if the buffer % changes
	if (millis() - prevMillis > 500 || override)
	{
		// Capture current values for next time
		prevMillis = millis();

		// Calculate the percentage (ESP32 has FP processor so shoud be efficient)
		float bufLevel = (float)bufferLevel;
		float arraySize = (float)(CIRCULARBUFFERSIZE);
		bufferPerCent = (bufLevel / arraySize) * 100.0;

		// Stop the annoying flicker from 99% to 100%, just assume over 95% is 100%
		bufferPerCent = bufferPerCent > 95 ? 100 : bufferPerCent;

		// Only update the screen on real change (avoids flicker & saves time)
		if (bufferPerCent > prevBufferPerCent + 1 || bufferPerCent < prevBufferPerCent - 1 || override)
		{
			// Track the buffer percentage
			prevBufferPerCent = bufferPerCent;

			// Print at specific rectangular place
			// TODO: These should not be magic numbers
			uint16_t bgColour, fgColour;
			switch (bufferPerCent)
			{
			case 0 ... 30:
				bgColour = TFT_RED;
				fgColour = TFT_WHITE;
				break;

			case 31 ... 74:
				bgColour = TFT_ORANGE;
				fgColour = TFT_BLACK;
				break;

			case 75 ... 100:
				bgColour = TFT_DARKGREEN;
				fgColour = TFT_WHITE;
				break;

			default:
				bgColour = TFT_WHITE;
				fgColour = TFT_BLACK;
			};

			tft.fillRoundRect(BUFFER_X, BUFFER_Y, BUFFER_W, BUFFER_H, 5, bgColour);
			tft.drawRoundRect(BUFFER_X, BUFFER_Y, BUFFER_W, BUFFER_H, 5, TFT_RED);
			tft.setTextColor(fgColour, bgColour);
			tft.setFreeFont(&FreeSans9pt7b);
			tft.setTextSize(1);

			tft.setCursor(bufferPerCent == 100 ? BUFFER_X + 6 : BUFFER_X + 11, BUFFER_Y + 20);
			tft.printf("%d%%\n", bufferPerCent);
		}
	}
}

// On screen Station Change button (called from main.cpp when TFT touch detected)
// Note that the button is invisible and what you see is a bitmap.
bool getStnChangeButtonPress()
{
	uint16_t t_x = 0, t_y = 0;
	boolean pressed = tft.getTouch(&t_x, &t_y, 50);
	if (pressed && stnChangeBtn.contains(t_x, t_y))
	{
		//log_v("Stn Change: x=%d, y=%d\n", t_x, t_y);
		log_d("Station change button pressed");
		drawStnChangeBitmap(true);

		// While the button is pressed (screen is touched) wait
		while (!digitalRead(tftTouchedPin))
		{
			// give up remainder of this 1mS time slice
			taskYIELD();
		}

		log_d("Station change button released");
		return true;
	}

	return false;
}

// Increase brightness
void getPlusButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently or buffer will stop
	if (millis() - prevMillis > 150)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y);

		// Check if any key coordinate boxes contain the touch coordinates
		// and highlight the buttons appropriately
		if (pressed && plusBtn.contains(t_x, t_y))
		{
			plusBtn.press(true);
		}
		else
		{
			plusBtn.press(false);
		}

		if (plusBtn.justPressed())
		{
			drawPlusButton(true);

			// SCREEN BRIGHTNESS
			if (bulbStatus == BTN_ACTIVE)
			{
				log_v("Brighter!");

				if (prevTFTBright <= 235)
				{
					prevTFTBright += 20;
					ledcWrite(0, prevTFTBright);

					// Update visual indicator
					drawPercentageLine(BRIGHTNESS);

					//Store brightness level in EEPROM
					preferences.putUInt("Bright", prevTFTBright);
				}
			}

			// MUSIC VOLUME
			if (spkrStatus == BTN_ACTIVE)
			{
				log_v("Louder!");
				uint8_t playerVolume = player.getVolume();
				if (playerVolume < 100)
				{
					// Prevent going above 100
					//player.setVolume(min((int)playerVolume + 1, 100));
					userVolume++;
					targetVolume = userVolume;

					// Update visual indicator
					drawPercentageLine(VOLUME);

					//Store volume level in EEPROM
					preferences.putUInt("Volume", userVolume);
				}
			}
		}
		else if (plusBtn.justReleased())
		{
			drawPlusButton(false);
		}
	}
}

// Decrease brightness
void getMinusButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently or buffer will stop
	if (millis() - prevMillis > 150)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y);

		// Check if any key coordinate boxes contain the touch coordinates
		if (pressed && minusBtn.contains(t_x, t_y))
		{
			minusBtn.press(true);
		}
		else
		{
			minusBtn.press(false);
		}

		if (minusBtn.justPressed())
		{
			drawMinusButton(true);

			// SCREEN BRIGHTNESS
			if (bulbStatus == BTN_ACTIVE)
			{
				log_v("Dimmer!");

				if (prevTFTBright >= 20)
				{
					prevTFTBright -= 20;
					ledcWrite(0, prevTFTBright);

					// Update visual indicator
					drawPercentageLine(BRIGHTNESS);

					//Store brightness level in EEPROM
					preferences.putUInt("Bright", prevTFTBright);
				}
			}

			// SPEAKER VOLUME
			if (spkrStatus == BTN_ACTIVE)
			{
				log_v("Quieter!");
				uint8_t playerVolume = player.getVolume();

				// Only allow reduction to +50 (very, very quiet)
				if (playerVolume >= 50)
				{
					//player.setVolume(playerVolume - 1);
					userVolume = playerVolume - 1;
					targetVolume = userVolume;

					// Update visual indicator
					drawPercentageLine(VOLUME);

					//Store volume level in EEPROM
					preferences.putUInt("Volume", userVolume);
				}
			}
		}
		else if (minusBtn.justReleased())
		{
			drawMinusButton(false);
		}
	}
}

// Speaker button to control volume and muting (stays active until bulb button pressed)
void getSpkrButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently
	if (millis() - prevMillis > 250)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Did we press the spearker button icon/button
		boolean pressed = tft.getTouch(&t_x, &t_y, 20);
		if (pressed && spkrBtn.contains(t_x, t_y))
		{
			log_d("Speaker button pressed");

			// Deactivate the bulb button if required
			if (bulbStatus == BTN_ACTIVE)
			{
				// Clear percentage line (from brightness)
				drawPercentageLine(CLEAR);

				// Disable bulb icon
				bulbStatus = BTN_INACTIVE;
				drawBulbBitmap(bulbStatus);

				// Enable speaker icon
				spkrStatus = BTN_ACTIVE;
				drawSpkrBitmap();

				// In/activate the plus/minus buttons depending on mute state
				// No change in volume level required here, continue with old value
				if (isMutedState)
				{
					drawDummyPlusMinusButtons();
				}
				else
				{
					drawPlusButton(false);
					drawMinusButton(false);
				}

				// Show current volume
				drawPercentageLine(VOLUME);

				// While the button is pressed (screen is touched) wait, to stop
				// the mute/unmute state switching many times whilst being pressed
				while (!digitalRead(tftTouchedPin))
				{
					// give up remainder of this 1mS time slice
					taskYIELD();
				}
			}
			else
			{
				// The speaker button is already ACTIVE we can toggle the mute sound
				isMutedState = !isMutedState;
				log_d("Mute: %s", isMutedState ? "Muted" : "UNmuted");

				// If we have unmuted the sound turn it up and vice versa
				// Volume will be adjusted in main loop(). NB Min volume = 1 to stop clicks
				targetVolume = isMutedState ? 1 : userVolume;
				drawSpkrBitmap();

				// In/activate the plus/minus buttons depending on mute state
				if (isMutedState)
				{
					drawDummyPlusMinusButtons();
				}
				else
				{
					drawPlusButton(false);
					drawMinusButton(false);
				}

				// While the button is pressed (screen is touched) wait to stop
				// the mute/unmute state switching many times
				while (!digitalRead(tftTouchedPin))
				{
					// give up remainder of this 1mS time slice
					taskYIELD();
				}
			}
		}
	}
}

// Brightness BULB icon
void getBulbButtonPress()
{
	static unsigned long prevMillis = millis();

	// Only do this infrequently and only if mute button not active
	if (millis() - prevMillis > 500)
	{
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Update the last time we were here
		prevMillis = millis();

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y, 50);

		// Check if any key coordinate boxes contain the touch coordinates
		if (pressed && bulbBtn.contains(t_x, t_y))
		{
			log_d("Bulb button pressed");

			// Clear percentage line (from volume)
			drawPercentageLine(CLEAR);

			// Draw activated bulb button
			bulbStatus = BTN_ACTIVE;
			drawBulbBitmap(bulbStatus);

			// Deactivate the speaker icon
			spkrStatus = BTN_INACTIVE;
			drawSpkrBitmap();

			// Paint the plus/minus buttons
			if (bulbStatus == BTN_ACTIVE)
			{
				drawMinusButton(false);
				drawPlusButton(false);
			}

			// Show the current brightness
			drawPercentageLine(BRIGHTNESS);
		}
	}
}

void displayStationName(std::string stationName)
{
	if (currDisplayScreen != HOME)
	{
		log_v("Not on HOME screen - no Station Name displayed");
		return;
	}

	// Set text colour and background
	tft.setTextColor(TFT_YELLOW, TFT_BLACK);

	// Clear the remainder of the line from before (eg long title)
	tft.fillRect(0, 56, 320, 40, TFT_BLACK);

	// Write station name (as stored in the sketch)
	tft.setCursor(0, 85);
	tft.setFreeFont(&FreeSansOblique12pt7b);
	tft.setTextSize(1);
	tft.println(stationName.c_str());
}

// Incoming string will normally be in the format Artist - Title
// But some stations do it the other way around. No standards here.
// Some do this: "Artist - Title - Artist - Title" What is this?
// But some titles do have another delimiter for the subtitle: Nino Rota - The Godfather - Love Theme'
void displayTrackArtist(std::string trackArtistIn)
{
	if (currDisplayScreen != HOME)
	{
		log_v("Not on HOME screen - no Title/Artist displayed");
		return;
	}

	// Placeholder strings for final output
	std::string justArtist = "";
	std::string justTitle = "";

	// Remove any strange quotes like this ` from the title. Eg Tchaikovsky - `Nutcracker`
	std::size_t posOfStrangeQuote = trackArtistIn.find("`");
	while (posOfStrangeQuote != std::string::npos)
	{
		trackArtistIn.erase(posOfStrangeQuote, 1);
		posOfStrangeQuote = trackArtistIn.find("`");
	}

	// Convert string to character array (because that's how I originally wrote this)
	char *trackArtist = (char *)trackArtistIn.c_str();

	// Did we split this string into track & artist successfully?
	bool splitSuccessful = false;

	// Find where the artist & track are split (if they are)
	char *pointerToDelimiter;
	pointerToDelimiter = strstr(trackArtist, " - ");
	int startCnt = (int)(pointerToDelimiter - trackArtist);

	// If a delimiter was found
	if (pointerToDelimiter != NULL)
	{
		log_v("Found artist/track delimiter at position %d", startCnt);

		// Make a new (sub) string of the first part (not including the delimiter)
		std::string justArtistTemp(&trackArtist[0], &trackArtist[startCnt]);
		justArtist = justArtistTemp;
		log_d("Artist: '%s'", justArtist.c_str());

		// Make a new (sub) string of the last part (skipping over the delimiter)
		std::string justTitleTemp(&trackArtist[startCnt + 3], trackArtistIn.size());
		justTitle = justTitleTemp;

		log_d("Title: '%s'", justTitle.c_str());

		// If the information is repeated again just truncate that, otherwise keep it.
		// First find the delimiter between artist & track
		std::size_t posOfExtraInfo = justTitle.find(" - ");
		if (posOfExtraInfo != std::string::npos)
		{
			// Extract the extra information after the delimiter
			std::string extraInfo = justTitle.substr(posOfExtraInfo + 3, justTitle.length());
			log_v("Extra track info: '%s'", extraInfo.c_str());

			// Is the Artist repeated in this extra info?
			std::size_t posOfRepeatedArtist = extraInfo.find(justArtist);
			if (posOfRepeatedArtist != std::string::npos)
			{
				log_v("Extra metadata info contains artist name (again)");

				// Remove ALL the repeating information
				pointerToDelimiter = strstr(justTitle.c_str(), " - ");
				if (pointerToDelimiter != NULL)
				{
					std::string justTitleTemp(&justTitle[0], pointerToDelimiter);
					justTitle = justTitleTemp;
					log_d("Truncated Title: '%s'", justTitle.c_str());
				}
			}
		}

		// Success
		splitSuccessful = true;
	}
	else
	{
		// Couldn't find a delimiter
		log_v("No delimiter found - using default value");
	}

	// Set default text colour and background
	tft.setTextColor(TFT_GREEN, TFT_BLACK);

	// Set artist / track info font size
	tft.setFreeFont(&FreeSans9pt7b);
	tft.setTextSize(1);
	tft.setCursor(0, 120);

	// Clear the remainder of the line from before (eg long title)
	tft.fillRect(0, 100, 320, 80, TFT_BLACK);

	// Change colours if we split the string successfully
	if (splitSuccessful)
	{
		// Will Artist fit onto one line? If not, reduce the font size
		int titleWidth = tft.textWidth(justArtist.c_str());
		log_v("Artist text width is %d pixels", titleWidth);
		if (titleWidth > 320)
		{
			tft.setTextFont(2);
			tft.setCursor(0, 110);
		}

		// Default colour
		tft.println(justArtist.c_str());

		// Manually position the text as we may have upset the postioning due to long titles
		tft.setCursor(0, 145);

		// Larger font, differentiating colour
		tft.setFreeFont(&FreeSans12pt7b);

		// If the larger font won't fit onto one line, try a smaller font
		// TODO: Ensure no more than two lines are used in total for title
		titleWidth = tft.textWidth(justTitle.c_str());
		log_v("Title text width is %d pixels", titleWidth);
		if (titleWidth > 320)
		{
			tft.setFreeFont(&FreeSans9pt7b);

			// If title still exceeds TWO lines (and would impact buttons) reduce to tiny font
			titleWidth = tft.textWidth(justTitle.c_str());
			if (titleWidth > 640)
			{
				log_d("Title text width is now %d pixels", titleWidth);
				tft.setTextFont(2);
				tft.setCursor(0, 130);
			}
		}

		tft.setTextColor(TFT_ORANGE, TFT_BLACK);
		tft.println(justTitle.c_str());
	}
	else
	{
		// Default colour
		tft.print(trackArtistIn.c_str());
		log_v("Track/Artist (combined) displayed on screen");
	}
}

// Inactive plus/minus buttons, only shown when sound is muted
void drawDummyPlusMinusButtons()
{
	tft.setFreeFont(&FreeSansBold12pt7b);
	dummyPlusBtn.drawButton();
	dummyMinusBtn.drawButton();
}

// Just for debugging, how many times do we fail to get data from the stream?
void drawFailureStreamingCount(int failCount)
{
	static int prevFailCount = 99;

	if (failCount != prevFailCount)
	{
		// Remove previous value
		prevFailCount = failCount;
		tft.fillRect(5, 190, 50, 30, TFT_BLACK);

		if (failCount > 1)
		{
			tft.setTextFont(2);
			tft.setTextColor(TFT_YELLOW, TFT_BLACK);
			tft.setCursor(5, 190);
			tft.print("Read fail: ");
			tft.print(failCount);
		}
	}
}

// Generic wait for button press then release
bool getBtnPressAndRelease(TFT_eSPI_Button btn)
{

	// Only allow this to run infrequently to prevent stalls
	static unsigned long prevMillis = 0;

	// Arbitrary delay between checks (in mS)
	if (millis() - prevMillis > 150)
	{
		prevMillis = millis();
		uint16_t t_x = 0, t_y = 0; // To store the touch coordinates

		// Pressed will be set true is there is a valid touch on the screen
		boolean pressed = tft.getTouch(&t_x, &t_y, 30);

		// Check if any key coordinate boxes contain the touch coordinates
		if (pressed && settingsBtn.contains(t_x, t_y))
		{
			log_d("Button pressed");

			// Redisplay button in inverse (user feedback)
			tft.setFreeFont(&FreeSans9pt7b);
			btn.drawButton(true);

			// Wait for release
			while (!digitalRead(tftTouchedPin))
			{
				// give up remainder of this 1mS time slice
				doCriticalTasks();
				taskYIELD();
			}

			log_d("Button released");

			// Display the button non-inverse
			tft.setFreeFont(&FreeSans9pt7b);
			btn.drawButton(false);

			// Button was released
			return true;
		}
	}

	// Either screen was not pressed, or press was not for this button
	return false;
}